# Codeforces Roadmap: From 800–900 to 900–1100

This roadmap is designed for your current solved profile (implementation, strings, counting, sets, basic math).

## Stage 0: Keep your current base strong (1 week)

**Goal:** Improve speed + accuracy on familiar patterns.

- Fast input parsing and edge-case checks.
- String transforms: reverse, normalize, compare, construct.
- Counting with conditions and simple set/map use.
- Divisibility and remainder formulas.

**Practice style:**
- 8–12 problems around 800–900 with a strict time limit (15–20 min/problem).
- After each solve, write a 2-line note: key trick + common bug to avoid.

---

## Stage 1: Core upgrade patterns for 900–1000

### 1) Frequency map / Counter thinking

**Why:** Many 900+ problems become easy once you convert values to counts.

**Patterns to add:**
- Character/integer frequency maps.
- Compare two multisets via sorted arrays or maps.
- "Can form / can transform" checks using counts.

**Typical signals in statement:**
- "Rearrange", "anagram", "same elements", "at most k replacements".

### 2) Prefix sums (1D)

**Why:** Repeated range-sum queries appear often.

**Patterns to add:**
- Build prefix array.
- Answer [l, r] sum in O(1).
- Use parity/count prefix variants (prefix of odds, zeros, etc.).

**Typical signals:**
- Many queries on static array/string.
- Sum/count over ranges.

### 3) Greedy with sorting

**Why:** 900–1000 has many "best local choice after sorting" tasks.

**Patterns to add:**
- Sort, then pick by smallest/largest.
- Pairing after sort.
- Interval-like one-pass picks after ordering.

**Typical signals:**
- "Minimum operations", "maximize score", "choose k items".

### 4) Two pointers (simple)

**Why:** Efficient scanning replaces nested loops.

**Patterns to add:**
- Opposite-end pointers (palindrome/compare).
- Same-direction window for basic constraints.
- Merge-like walk across two sorted arrays.

**Typical signals:**
- "Subarray/subsequence", "closest pair", "remove minimal segment".

---

## Stage 2: Bridge patterns for 1000–1100

### 5) Binary search on answer (easy form)

**Why:** Common jump in 1000–1100 where direct formula is not obvious.

**Patterns to add:**
- Identify monotonic condition.
- Search minimum/maximum feasible value.
- Build and test `check(mid)` helper.

**Typical signals:**
- "Minimum x such that...", "maximum possible..." with monotonic behavior.

### 6) Constructive implementation

**Why:** Many A/B problems ask you to output a valid configuration.

**Patterns to add:**
- Build answer step-by-step under constraints.
- Validate invariants while constructing.
- Handle impossible cases early.

**Typical signals:**
- "Print any valid", "construct string/permutation", "if impossible print -1".

### 7) Basic simulation on grids/matrices

**Why:** 1000-ish often includes straightforward matrix logic.

**Patterns to add:**
- Direction vectors.
- Boundary checks.
- Row/column condition scans.

### 8) Math mini-patterns

**Why:** Small math observations save lots of time.

**Patterns to add:**
- GCD/LCM basics.
- Parity (odd/even) reasoning.
- Ceiling/floor transforms.
- Modular arithmetic with positive normalization.

---

## Weekly plan (4-week cycle)

### Week 1 (900 focus)
- 12 problems: frequency maps, sorting-greedy, strings.
- Target: average under 25 min.

### Week 2 (900–1000 focus)
- 10 problems: prefix sums + two pointers.
- Add 2 virtual contest sessions.

### Week 3 (1000 focus)
- 8 problems: constructive + matrix simulation.
- 4 problems: easy binary search on answer.

### Week 4 (1000–1100 bridge)
- 12 mixed problems from all above patterns.
- Re-solve 6 previously failed problems without editorials.

---

## Problem-solving checklist (use for every attempt)

1. Classify problem in 30 seconds: string / count / greedy / prefix / two-pointer / BS / constructive.
2. Write constraints and target complexity before coding.
3. Create 3 manual tests:
   - smallest edge,
   - typical random,
   - adversarial corner case.
4. Keep code template simple; avoid overengineering.
5. Post-solve note:
   - pattern used,
   - one mistake made,
   - one speed improvement for next time.

---

## Milestones to track

- **Milestone A:** 30 solves at 900–1000 with >70% first-attempt AC.
- **Milestone B:** 20 solves at 1000–1100 where at least 8 involve prefix/two-pointer/greedy composition.
- **Milestone C:** 3 consecutive virtual contests with no implementation WA due to parsing/indices.

---

## Suggested next pattern order (strict)

1. Frequency map
2. Sorting + greedy
3. Prefix sums
4. Two pointers
5. Constructive
6. Binary search on answer
7. Grid simulation
8. Math (GCD/parity/mod)

If you follow this order, your current 800–900 strengths transfer cleanly into stable 900–1100 performance.
